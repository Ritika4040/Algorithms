Introduction to Disjoint Sets

Disjoint sets (also called union-find) are a data structure for managing a collection of disjoint subsets.
They support efficient operations to merge sets (union) and find which set an element belongs to (find). 
Commonly used in algorithms like Kruskal's for minimum spanning trees or cycle detection in graphs. 

Basic Operations

MakeSet(x): Creates a new set containing only element x. Each element points to itself as the parent (e.g., parent[x] = x).
Find(x): Returns the representative (root) of the set containing x. Without optimizations, it traverses the parent chain to the root.
Union(x, y): Merges the sets containing x and y. Without optimizations, it simply sets the parent of one root to the other, potentially creating long chains.

Weighted Union (Union by Rank)
To optimize union, use "union by rank" (or weighted union) to attach smaller trees under larger ones, preventing tall trees:

Maintain a rank array where rank[root] approximates the tree height.
In Union(x, y), find roots rx and ry. If rank[rx] > rank[ry], set parent[ry] = rx. If equal, set parent[ry] = rx and increment rank[rx].
This keeps trees balanced, reducing find time. Example: Merging sets of sizes 1 and 2 attaches the smaller to the larger.

Collapsing Find (Path Compression)
Optimizes find by flattening the tree during traversal:

When finding the root, update each node's parent to point directly to the root.
Recursive implementation: find(x) { if (parent[x] != x) parent[x] = find(parent[x]); return parent[x]; }
Iterative version possible but recursive is simpler. This makes future finds faster by shortening paths.
Example: In a chain A->B->C, finding A sets A->C and B->C.

Time Complexity
Without optimizations: Union and Find are O(n) in worst case (e.g., a long chain).
With union by rank and path compression: Amortized time is nearly O(1) per operation (inverse Ackermann function α(n), 
which grows very slowly and is effectively constant for practical n).
Proof involves analyzing tree heights; Bari illustrates with examples showing how operations become efficient.

Applications and Examples

Cycle Detection: In undirected graphs, use union-find to check if adding an edge creates a cycle (if find(u) == find(v), cycle exists).
Kruskal's Algorithm: Sort edges by weight, add if they connect different sets.
Video example: Processing edges like {1,2}, {3,4}, {1,3}—demonstrates unions and finds with optimizations.
Bari emphasizes implementation in code (e.g., arrays for parent and rank) and edge cases like self-loops or disconnected components.

Key Takeaways

Start with basic union-find, then add rank for union and compression for find.
These optimizations make it suitable for large datasets (e.g., n=10^5 elements).
